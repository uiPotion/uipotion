{
  "$schema": "https://uipotion.com/schema/categories/components.schema.json",
  "id": "dialog",
  "version": "1.0.0",
  "name": "Modal Dialog (Accessible) with Focus Trap and Actions",
  "category": "components",
  "tags": [
    "modal",
    "dialog",
    "overlay",
    "focus-trap",
    "a11y",
    "wcag",
    "aria"
  ],
  "description": "An accessible modal dialog component with focus trapping, Escape/backdrop dismissal rules, scroll locking, and action footer. Includes confirm/alert variants and responsive fullscreen behavior on small screens.",
  "tokens": {
    "layout": {
      "zIndex": {
        "overlayBackdrop": 40,
        "dialog": 50,
        "tooltips": 60
      }
    },
    "motion": {
      "openDurationMs": 180,
      "closeDurationMs": 140,
      "easing": "cubic-bezier(0.2, 0, 0, 1)"
    }
  },
  "aiAgentInstructions": {
    "summary": "Implement a reusable modal dialog with overlay backdrop, focus trap, and keyboard accessibility. Adapt to the user's framework and styling system. Ensure WCAG AA compliance, including Escape handling, focus restoration, and ARIA attributes.",
    "keyFeatures": [
      "Accessible semantics: role='dialog' or role='alertdialog', aria-modal, aria-labelledby, aria-describedby",
      "Focus trap while open; restore focus to trigger on close",
      "Dismiss rules: Escape closes when dismissible; optional backdrop click close",
      "Body scroll lock while open; preserve scroll position",
      "Responsive sizing: centered dialog on desktop; optional fullscreen on mobile",
      "Animations with prefers-reduced-motion support",
      "Action footer: primary/secondary buttons; loading/disabled states",
      "CRITICAL: Styling MUST match the project's existing conventions. Detect framework and styling system first, then use ONLY that system. Do NOT introduce new styling systems.",
      "CRITICAL: When detecting vanilla CSS, ALWAYS create CSS classes in a stylesheet. NEVER use inline style attributes on HTML elements. Define classes like .dialog, .dialog--open, .backdrop, etc. and apply them via className/class attributes.",
      "CRITICAL: When detecting React, extract logic from useEffect hooks into separate custom hooks that do ONE thing each. For example: useFocusTrap(), useBodyScrollLock(), useDialogState(). This improves code organization, testability, and reusability."
    ],
    "implementationSteps": [
      "0. CRITICAL: Detect the project's framework and styling system BEFORE writing any code. Examine: (a) package.json for framework (React, Vue, Angular, Svelte) and styling dependencies (tailwindcss, styled-components, emotion, sass, etc.), (b) existing component files to see how they import styles (CSS Modules, Tailwind classes, styled-components, etc.), (c) config files (tailwind.config.js, vite.config.js, webpack.config.js, etc.), (d) existing style files and their structure. If the project uses Tailwind, use Tailwind. If SCSS/CSS, use SCSS/CSS. If styled-components, use styled-components. If nothing is configured, use the most suitable CSS approach (vanilla CSS or CSS Modules).",
      "0a. Detect framework patterns: Check how existing components are structured (hooks in React, composition API in Vue, etc.), how state is managed, and what patterns are used.",
      "0b. Detect styling conventions: Identify class naming (BEM, camelCase, kebab-case), how styles are imported, whether there's a design system or token system, and what utility functions exist (cn, clsx, classnames, etc.).",
      "0c. If detection is uncertain, ask the user about their styling approach and framework before proceeding.",
      "1. Build component anatomy: Trigger, Backdrop, Dialog, Header, Body, Footer",
      "2. Implement open/close state and controlled/uncontrolled usage",
      "3. Add focus trap (manual or library) and focus restoration to trigger",
      "4. Add Escape and backdrop click handlers based on dismissible config",
      "5. Add scroll locking and cleanup on close/unmount",
      "6. Apply ARIA: aria-modal, aria-labelledby, aria-describedby; set role based on variant",
      "7. Add animations + prefers-reduced-motion behavior",
      "8. Provide confirm/alert variants and responsive fullscreen option",
      "9. Use ONLY the detected styling system. Do NOT add <style> blocks, inline styles, or new CSS files unless that's the project's convention. Match existing component styling patterns exactly.",
      "10. Provide test checklist for keyboard + screen reader flows"
    ]
  },
  "componentSpec": {
    "goal": "Provide a safe, accessible modal dialog for confirmations, forms, and focused tasks without leaving the current page context.",
    "anatomy": {
      "slots": [
        "trigger",
        "backdrop",
        "dialog",
        "title",
        "description",
        "body",
        "footer",
        "closeButton"
      ],
      "hierarchy": "Trigger → Backdrop → Dialog( Header(Title, Close), Body, Footer(Actions) )"
    },
    "stateModel": {
      "open": {
        "type": "boolean",
        "description": "Whether the dialog is open.",
        "default": false,
        "persistence": "component state only"
      },
      "loading": {
        "type": "boolean",
        "description": "Whether primary action is processing; disables actions and optionally shows spinner.",
        "default": false,
        "persistence": "component state only"
      },
      "variant": {
        "type": "enum",
        "description": "Dialog semantics variant; alertdialog is used for urgent confirmations.",
        "default": "dialog",
        "allowedValues": [
          "dialog",
          "alertdialog"
        ],
        "persistence": "props/config"
      },
      "dismissible": {
        "type": "boolean",
        "description": "If true, Escape and (optionally) backdrop click can close the dialog.",
        "default": true,
        "persistence": "props/config"
      },
      "closeOnBackdropClick": {
        "type": "boolean",
        "description": "If true and dismissible=true, clicking backdrop closes the dialog.",
        "default": true,
        "persistence": "props/config"
      },
      "fullscreenOnMobile": {
        "type": "boolean",
        "description": "If true, dialog becomes fullscreen on small screens.",
        "default": true,
        "persistence": "props/config"
      }
    },
    "interactions": [
      {
        "event": "triggerClick",
        "result": "openDialog",
        "sideEffects": [
          "captureTriggerElementForFocusRestore",
          "lockBodyScroll",
          "moveFocusToInitialElement"
        ]
      },
      {
        "event": "escapeKey",
        "when": "open && dismissible",
        "result": "closeDialog",
        "sideEffects": [
          "restoreFocusToTrigger",
          "unlockBodyScroll"
        ],
        "preventDefault": true,
        "stopPropagation": true,
        "accessibilityNotes": "Escape should close and return focus to the element that opened the dialog."
      },
      {
        "event": "backdropClick",
        "when": "open && dismissible && closeOnBackdropClick",
        "result": "closeDialog",
        "sideEffects": [
          "restoreFocusToTrigger",
          "unlockBodyScroll"
        ],
        "stopPropagation": true
      },
      {
        "event": "closeButtonClick",
        "when": "open",
        "result": "closeDialog",
        "sideEffects": [
          "restoreFocusToTrigger",
          "unlockBodyScroll"
        ]
      },
      {
        "event": "primaryActionClick",
        "when": "open && !loading",
        "result": "invokePrimaryAction",
        "sideEffects": [
          "setLoadingTrue",
          "disableActions"
        ]
      },
      {
        "event": "primaryActionResolved",
        "when": "open",
        "result": "closeDialog",
        "sideEffects": [
          "setLoadingFalse",
          "restoreFocusToTrigger",
          "unlockBodyScroll"
        ]
      },
      {
        "event": "primaryActionRejected",
        "when": "open",
        "result": "keepDialogOpen",
        "sideEffects": [
          "setLoadingFalse",
          "announceErrorOptional"
        ]
      }
    ],
    "responsiveBehavior": {
      "mobile": {
        "maxWidthPx": 767,
        "behavior": "If fullscreenOnMobile=true, dialog uses fullscreen layout; otherwise uses near-full width with margins.",
        "padding": "16px"
      },
      "desktop": {
        "minWidthPx": 1024,
        "maxDialogWidthPx": 640,
        "bodyMaxHeight": "calc(100vh - 200px)",
        "bodyOverflow": "auto"
      }
    },
    "variants": {
      "confirm": "Shows primary and secondary buttons. Backdrop click allowed if dismissible.",
      "alert": "Uses role='alertdialog'. Prefer closeOnBackdropClick=false to avoid accidental dismissal."
    }
  },
  "animations": {
    "open": {
      "durationMs": 180,
      "easing": "cubic-bezier(0.2, 0, 0, 1)",
      "backdrop": {
        "opacity": "0 → 1"
      },
      "dialog": {
        "opacity": "0 → 1",
        "transform": "translateY(8px) scale(0.98) → translateY(0) scale(1)"
      }
    },
    "close": {
      "durationMs": 140,
      "easing": "cubic-bezier(0.2, 0, 0, 1)",
      "backdrop": {
        "opacity": "1 → 0"
      },
      "dialog": {
        "opacity": "1 → 0",
        "transform": "translateY(0) scale(1) → translateY(8px) scale(0.98)"
      }
    }
  },
  "accessibility": {
    "wcagCompliance": {
      "level": "AA",
      "requirements": {
        "2.1.1": "All dialog controls operable via keyboard; focus is trapped within dialog while open.",
        "2.1.2": "No keyboard trap beyond intended focus trap; Escape exits when dismissible.",
        "2.4.3": "Logical focus order; initial focus placed inside dialog; focus returns to trigger on close.",
        "2.4.7": "Visible focus indicators for all interactive elements.",
        "4.1.2": "Correct ARIA roles, names, and relationships."
      }
    },
    "keyboardNavigation": {
      "escapeKey": "Closes dialog when dismissible=true; always restore focus to trigger.",
      "tabKey": "Trapped within dialog. Tabbing cycles through focusable elements; Shift+Tab cycles backwards.",
      "initialFocus": "Prefer first focusable element in body, else close button, else primary action button."
    },
    "ariaAttributes": {
      "required": {
        "dialog": {
          "role": "dialog or alertdialog (variant-dependent)",
          "aria-modal": "true",
          "aria-labelledby": "id of title element",
          "aria-describedby": "id of description/body element (when present)"
        },
        "closeButton": {
          "aria-label": "Close dialog"
        },
        "trigger": {
          "aria-haspopup": "dialog",
          "aria-expanded": "true/false"
        }
      },
      "optional": {
        "statusRegion": {
          "role": "status",
          "aria-live": "polite",
          "usage": "Optional: announce loading or error messages."
        }
      }
    },
    "implementationChecklist": [
      "Trap focus inside dialog when open",
      "Restore focus to trigger on close (all close paths)",
      "Escape closes dialog only if dismissible=true",
      "Backdrop click closes only if closeOnBackdropClick=true",
      "role and aria-* attributes present and correctly wired",
      "Body scroll lock applied and cleaned up",
      "prefers-reduced-motion reduces or removes transforms"
    ]
  },
  "projectDetection": {
    "framework": {
      "description": "Detect the project's framework by examining package.json, existing component files, and project structure. Common frameworks: React, Vue, Angular, Svelte.",
      "detectionSteps": [
        "Check package.json for framework dependencies (react, vue, @angular/core, svelte)",
        "Examine existing component files for framework-specific patterns (JSX for React, .vue files for Vue, etc.)",
        "Check build configuration (vite.config.js, webpack.config.js, angular.json, etc.)",
        "Look for framework-specific directories (src/components, src/app, etc.)"
      ]
    },
    "stylingSystem": {
      "description": "Detect the project's styling approach by examining dependencies, config files, and existing component styles. Use the detected system exclusively.",
      "detectionSteps": [
        "Check package.json for styling dependencies: tailwindcss, styled-components, emotion, sass, less, css-modules, etc.",
        "Look for config files: tailwind.config.js, postcss.config.js, sass config, etc.",
        "Examine existing component files to see how styles are imported and used",
        "Check for style files: .css, .scss, .module.css, styled-components patterns, etc.",
        "Identify class naming conventions and utility functions (cn, clsx, classnames, etc.)",
        "If no styling system is detected, use vanilla CSS or CSS Modules as the most suitable approach"
      ],
      "adaptationRules": [
        "If Tailwind is detected: Use Tailwind utility classes, respect existing config, use existing design tokens, follow project's class composition patterns",
        "If SCSS/CSS is detected: Use SCSS/CSS files matching project structure, follow existing naming conventions (BEM, camelCase, etc.), import styles as the project does",
        "If styled-components is detected: Use styled-components syntax matching project patterns, follow existing component structure",
        "If CSS Modules is detected: Use .module.css files, follow existing module naming patterns",
        "If no styling system: Use vanilla CSS with semantic class names, or CSS Modules if it seems appropriate for the project size"
      ]
    },
    "designTokens": {
      "description": "Identify existing design tokens, color systems, spacing scales, and typography from the project. Use these instead of inventing new values.",
      "detectionSteps": [
        "Check for design token files (tokens.json, theme.js, design-tokens.css, etc.)",
        "Examine Tailwind config for theme values if using Tailwind",
        "Look at existing components for color, spacing, and typography patterns",
        "Check CSS variables (--color-*, --spacing-*, etc.) in global styles",
        "If tokens exist, use them. If not, use values that match existing component styles"
      ]
    }
  },
  "outputConstraints": {
    "must": [
      "Detect and use ONLY the project's existing framework (React, Vue, Angular, Svelte) - match existing component patterns",
      "Detect and use ONLY the project's existing styling system (Tailwind, SCSS, CSS, styled-components, etc.) - match existing styling patterns",
      "Use project's existing design tokens, color system, and spacing scales if available",
      "Use project's class composition utility (cn, clsx, classnames, etc.) if it exists",
      "Follow project's naming conventions (BEM, camelCase, kebab-case, etc.)",
      "Match the structure and patterns of existing components in the project"
    ],
    "mustNot": [
      "Do NOT introduce new styling systems (if project uses Tailwind, don't add SCSS; if SCSS, don't add Tailwind)",
      "Do NOT add <style> blocks unless that's the project's convention (e.g., Vue SFC <style> blocks)",
      "Do NOT use inline style attributes unless necessary for dynamic values (use CSS variables if supported)",
      "Do NOT create new CSS/SCSS files unless that's how the project structures styles",
      "Do NOT hardcode colors/values - use project's design tokens or match existing component values",
      "Do NOT import new UI libraries or styling dependencies",
      "Do NOT use string concatenation for class names - use project's composition utility",
      "CRITICAL: When vanilla CSS is detected, NEVER use inline style attributes on HTML elements. ALWAYS create CSS classes in a stylesheet and apply them via className/class. Example: Create .dialog { max-width: 640px; } in CSS, then use <div class='dialog'> not <div style='max-width: 640px'>",
      "CRITICAL: When React is detected, NEVER put multiple concerns in a single useEffect. ALWAYS extract logic into separate custom hooks. Example: Instead of useEffect(() => { /* focus trap + scroll lock + escape handler */ }), create useFocusTrap(), useBodyScrollLock(), useEscapeHandler() hooks and use them separately"
    ]
  },
  "testingChecklist": [
    "Dialog opens from trigger and focus moves inside dialog",
    "Tab and Shift+Tab cycle within dialog only",
    "Escape closes when dismissible=true and restores focus to trigger",
    "Backdrop click closes only when enabled; does not close when disabled",
    "Close button always closes and restores focus",
    "role='dialog'/'alertdialog' correctly applied based on variant",
    "aria-labelledby and aria-describedby point to existing elements",
    "Body scroll is locked while open and restored on close",
    "On mobile, fullscreen variant renders correctly when enabled",
    "prefers-reduced-motion removes heavy transforms/animations",
    "Styling uses only the detected project styling system (matches existing components)",
    "All styling matches project conventions and existing patterns"
  ],
  "aiImplementationPrompt": "Implement an accessible Modal Dialog component with overlay backdrop, focus trap, focus restoration to trigger, Escape/backdrop dismissal (configurable), and scroll lock. Support role='dialog' and role='alertdialog' variants, with aria-modal, aria-labelledby, aria-describedby, and aria-expanded on the trigger. Provide header (title + close), body, footer (primary/secondary actions) and loading state for primary action. Add open/close animations with prefers-reduced-motion support. Adapt to {{USER_FRAMEWORK}} and {{USER_STYLING_LIBRARY}}. CRITICAL: If vanilla CSS is detected, create CSS classes in a stylesheet, never use inline styles. If React is detected, extract useEffect logic into separate custom hooks (one concern per hook).",
  "meta": {
    "created": "2026-01-11",
    "updated": "2026-01-11",
    "webUrl": "https://uipotion.com/potions/components/modal-dialog.html"
  }
}
